## System Design: SingleStore

The most interesting aspect of SingleStore (for my purposes, at least) is the execution engine. The NoisePage execution engine is largely modeled off of the SingleStore architecture inherited from MemSQL. The high-level description of this architecture is described in Drew Paroski's article _Code Generation: The Inner Sanctum of Database Performance_. 

In addition to the code generation techniques advocated by Paroski, it appears that SingleStore has also added support for adaptive query compilation (a. la. HyPer) wherein queries are both interpreted and compiled when they are first encountered and the compiled plan is cached and used to process requests on subsequent invocations. One question that I have here is the granularity at which plans are compiled. For instance, the documentation states that the same compiled plan is used to service multiple requests even when the predicate for the query changes - all queries that have the same "shape" use the same cached, compiled plan. Does this mean that the predicate is re-compiled each time? Is there a separate cache of little "query components" (like predicates) that is persist these compiled chunks? Then at runtime query execution becomes glueing together mutliple compiled components into the final compiled query?

I feel like there is a fundamental tradeoff here between the storage / memory efficiency of the implementation and the execution time for individual queries. You pay a price for not completely specializing the generated machine code for each specific query (predicate included) but as a consequence you don't need to compile a distinct plan for individual queries that only differ by the predicate associated with a `SELECT` (as just one example). By "price" here I am imagining that there are certain optimizations one cannot apply when the entirety of the plan is not available. However, it might be possible to get around this by simple caching the query in an intermediate representation (bytecode module? LLVM IR?) and only optimizing + compiling to native code once the entirety of the plan is available.

The documentation leaves a lot to be desired in terms of the details it provides on the implementation, but I suppose this is to be expected for a closed-source system like SingleStore. However, the documentation hints that SingleStore is able to compile UDFs to native code the same way it does for SQL queries. I need to investigate this further...