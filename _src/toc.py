"""
Generate a table of contents Markdown file for a particular directory.
"""

import argparse
import json
import logging
import os
import re
import sys
from typing import Dict, List, Optional, Tuple

# Script exit codes
EXIT_SUCCESS = 0
EXIT_FAILURE = 1

# The name of the README file to overwrite
README = "README.md"

# The prefix that denotes a paper title in a file
TITLE_PREFIX = "##"

# The prefix that denotes a section header
SECTION_PREFIX = "###"

# The pattern to match a publication date in a paper title
PUBLICATION_DATE_PATTERN = "\([0-9]+\)"

# -----------------------------------------------------------------------------
# Argument Parsing


def parse_arguments() -> Tuple[str, Optional[str]]:
    """
    Parse commandline arguments.
    :return (directory_path, config_path)
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "path",
        type=str,
        help="The path to the directory for which the TOC is generated.",
    )
    parser.add_argument("--config", "-c", type=str, help="The path to the config file.")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output.")
    args = parser.parse_args()
    return args.path, args.config, args.verbose


# -----------------------------------------------------------------------------
# Config Parsing


def find_config(path: str) -> str:
    """
    Locate the configuration file in the given directory.
    :param path The path to the directory
    :return The path to the config in the directory
    """
    assert os.path.isdir(path), "Broken precondition."
    for fname in os.listdir(path):
        fpath = os.path.join(path, fname)
        if os.path.isfile(fpath) and os.path.splitext(fname)[1] == ".json":
            return fpath
    raise RuntimeError(f"No configuration file found in {path}")


def load_config(path: str) -> Dict[str, str]:
    """
    Load a config file from `path`.
    :param path The path to the file
    :return The configuration loaded as a Python dictionary
    """
    assert path is not None, "Broken precondition."

    if os.path.isdir(path):
        path = find_config(path)

    assert os.path.isfile(path), "Broken invariant."

    try:
        with open(path, "r") as f:
            return json.load(f)
    except json.JSONDecodeError:
        raise RuntimeError(f"Invalid configuration file: {path}.") from None


# -----------------------------------------------------------------------------
# File Parsing


def title_from_file(path: str) -> str:
    """
    Read a paper title from the specified file path.
    :param path The path to the file
    :return The paper title parsed from this file
    """
    with open(path, "r") as f:
        for line in f:
            if line.startswith(TITLE_PREFIX):
                return line.strip(TITLE_PREFIX).strip()


def titles_for_directory(path: str) -> List[Tuple[str, str]]:
    """
    Get all paper titles in the directory specified by `path`.
    :param path The directory path
    :return A list of tuples (filename, title) for each paper in the directory.
    """
    return [(fn, title_from_file(os.path.join(path, fn))) for fn in os.listdir(path)]


def publication_date(title: str) -> int:
    """
    Parse the publication date from a paper title.
    :param title The title string
    :return The publication date
    """
    match = re.search(PUBLICATION_DATE_PATTERN, title)
    if match is None:
        return 0
    return int(match.group(0).lstrip("(").rstrip(")"))


# -----------------------------------------------------------------------------
# File I/O


def write_line(file, line: str):
    """
    Write a line to a file, with terminating newline.
    :param file The file to which output is written
    :param line The line to write
    """
    file.write(line)
    file.write("\n")


def write_title(file):
    """
    Write the title.
    :param file The file to which output is written
    """
    write_line(file, f"{TITLE_PREFIX} Bibliography")
    write_line(file, "")
    write_line(
        file,
        "This file is automatically generated from the contents of this directory.",
    )
    write_line(file, "")


def link_for(section: str) -> str:
    """
    Generate the link for a particular section title.
    :param section The title of the section
    :return The link to this section
    """
    return f"#{section.lower().replace(' ', '-')}"


def write_contents(file, papers):
    """
    Write the table of contents.
    :param file The file to which output is written
    :param papers The map from section -> paper titles
    """

    sections = [f"- [{k}]({link_for(k)})" for k in sorted(papers.keys())]
    sections = "\n".join(sections)
    write_line(file, f"{SECTION_PREFIX} Contents")
    write_line(file, "")
    write_line(file, sections)


def write_section(file, section, papers, subjects):
    """
    Write a single section.
    :param file The file to which output is written
    :param section The section title
    :param papers The list of tuples (filename, title)
    :param subjects The dictionary of subjects
    """
    # The prefix for the hyperlink
    prefix = f"./{subjects[section]}"

    # Sort by title publication date (ascending), alphabetical (ascending)
    items = sorted(papers, key=lambda x: (publication_date(x[1]), x[1]))
    items = [f"- [{title}]({prefix}/{filename})" for (filename, title) in items]
    items = "\n".join(items)

    write_line(file, "")
    write_line(file, f"{SECTION_PREFIX} {section}")
    write_line(file, "")
    write_line(file, items)


def write_sections(file, papers, subjects):
    """
    Write all sections.
    :param file The file to which output is written
    :param papers The dictionary of section title -> papers
    :param
    """
    for section, paper_titles in papers.items():
        write_section(file, section, paper_titles, subjects)


# -----------------------------------------------------------------------------
# Main


def main():
    target_path, config_path, verbose = parse_arguments()
    logging.basicConfig(level=logging.INFO if verbose else logging.ERROR)

    # Load the configuration
    try:
        subjects = load_config(target_path if config_path is None else config_path)
    except RuntimeError as e:
        logging.error(f"[-] {e}")
        return EXIT_FAILURE

    papers = {
        subject: titles_for_directory(os.path.join(target_path, directory))
        for subject, directory in subjects.items()
    }
    if len(papers) == 0:
        logging.warning(f"[+] Target directory contains no papers, exiting.")
        return EXIT_SUCCESS

    with open(os.path.join(target_path, README), "w") as file:
        write_title(file)
        write_contents(file, papers)
        write_sections(file, papers, subjects)

    logging.info(f"[+] Updated contents for directory {target_path}.")
    return EXIT_SUCCESS


# -----------------------------------------------------------------------------
# Script Entry

if __name__ == "__main__":
    sys.exit(main())
